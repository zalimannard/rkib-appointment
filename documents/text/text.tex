\documentclass[a4paper,article]{article}

% Шрифты
\usepackage{fontspec}
\usepackage[14pt]{extsizes}
\setmainfont{Times New Roman}

% Языки
% Русский обязательно идёт вторым. Иначе не работают переносы
\usepackage[english, russian]{babel}

% Параметры страницы
\usepackage[left=3cm, top=2cm, right=1.5cm, bottom=2cm]{geometry}
\usepackage[onehalfspacing]{setspace}

% Параметры текста
% По умолчанию LaTeX не делает отступ после \section. Вроде как оно и не надо, но в тексте ВКР пусть лучше будет. В требованиях отступ описан. Этот пакет своим наличием добавляет этот отступ
\usepackage{indentfirst}
% По умолчанию абзацный отстум меньше требуемого. Задаём конкретный
\setlength{\parindent}{1.25cm}

% Ссылки
\usepackage{color}
\definecolor{Black}{RGB}{0,0,0}
% Без colorlinks вокруг ссылок появляются рамки, недопустимые в ВКР
% Если не зачернить ссылки, то в оглавлении и в других местах будут яркие цвета
\usepackage[colorlinks, allcolors=Black]{hyperref}
% Шрифт для URL
\urlstyle{rm}

% Пункты оглавления
\usepackage{titlesec}
\titleformat{\section}
{\centering\normalfont\bfseries}{\thesection. }{0em}{}
\titleformat{\subsection}
{\centering\normalfont\bfseries}{\thesubsection. }{0em}{}
\titleformat{\subsubsection}
{\centering\normalfont\bfseries}{\thesubsubsection. }{0em}{}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries\centering}{\theparagraph. }{0em}{}
% Список использованных источников
\addto\captionsrussian{\def\refname{Список использованных источников}}

% Нумерация
\setcounter{secnumdepth}{4}

% Таблицы
\usepackage{multicol}
\usepackage{xltabular}

% Перечисления
\usepackage{enumitem}

% Картинки
% Вставка картинок правильная
\usepackage{graphicx}
% "Плавающие" картинки
\usepackage{float}
% Обтекание фигур (таблиц, картинок и прочего)
\usepackage{wrapfig}
% Папка для всех картинок файла
\graphicspath{{images/}}
% Точка в конце названий объекта вместо двоеточия. Например, для Рисунков
\usepackage[labelsep=period]{caption}
% Вместо 'Рис. 1' чтобы было 'Рисунок 1'
\makeatletter
\renewcommand{\fnum@figure}{Рисунок \thefigure}
\makeatother

% Листинги
\usepackage{listings}
\usepackage{caption}

\lstdefinestyle{code}{
    frame=single,
    breaklines=true,
    captionpos=b,
    basicstyle=\small\sffamily,
    numbers=left,
    captionpos=t,
    numbersep=-15pt,
}
\lstset{style=code}

% Выравнивание списков
\setlist[itemize]{leftmargin=1.25cm}
\setlist[enumerate]{leftmargin=1.25cm}

\begin{document}
    \begin{titlepage}
        \begin{center}
            {\bfseries Министерство науки и высшего образования Российской Федерации \\
            Федеральное государственное автономное образовательное учреждение \\
            высшего образования \\
            <<КАЗАНСКИЙ (ПРИВОЛЖСКИЙ) ФЕДЕРАЛЬНЫЙ УНИВЕРСИТЕТ>>}
        \end{center}

        \begin{center}
            ИНСТИТУТ ВЫЧИСЛИТЕЛЬНОЙ МАТЕМАТИКИ И ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ
        \end{center}

        \begin{center}
            КАФЕДРА АНАЛИЗА ДАННЫХ И ТЕХНОЛОГИЙ ПРОГРАММИРОВАНИЯ
        \end{center}

        \begin{center}
            Направление: 09.03.03 – Прикладная информатика
        \end{center}

        \vspace{0mm}

        \begin{center}
            ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА \\
            {\bfseries СИСТЕМА ЗАПИСИ НА ПРИЁМ В МЕДИЦИНСКОЕ УЧРЕЖДЕНИЕ}
        \end{center}

        \vfill

        \begin{xltabular}{\textwidth} {
                >{\hsize=0.5\hsize} X
                >{\hsize=0.5\hsize} X }
            \bfseries{Работа завершена:} & \\
            Студент 4 курса & \\
            группы 09-951 & \\
            <<\underline{\hspace{1cm}}>>\underline{\hspace{3cm}} 2023г. & \underline{\hspace{3cm}}/Колесников Д.А. \\
            & \\
            \bfseries{Работа допущена к защите:} & \\
            Научный руководитель & \\
            старший преподаватель & \\
            <<\underline{\hspace{1cm}}>>\underline{\hspace{3cm}} 2023г. & \underline{\hspace{3cm}}/Еникеев И.А. \\
            & \\
            \multicolumn{2}{l}{Заведующий кафедрой анализа данных} \\
            и технологий программирования & \\
            <<\underline{\hspace{1cm}}>>\underline{\hspace{3cm}} 2023г. & \underline{\hspace{3cm}}/Бандеров В.В. \\
        \end{xltabular}

        \vspace{0mm}

        \begin{center}
            Казань — 2023
        \end{center}
    \end{titlepage}

    \newpage

    \setcounter{page}{2}

    \tableofcontents

    \newpage

    \section*{Глоссарий}
    \addcontentsline{toc}{section}{Глоссарий}

    \textbf{API} -- Описание способов взаимодействия одной компьютерной программы с другими~\cite{apiwikipedia}.

    \textbf{Backend (Бэкенд, серверная часть)} -- Часть веб-приложения или сайта, которая запускается на сервере. Отвечает за обработку запросов от фронтенда, выполнение бизнес-логики, взаимодействие с базами данных

    \textbf{CRUD} -- акроним, обозначающий четыре базовые функции, используемые при работе с базами данных: создание (create), чтение (read), модификация (update), удаление (delete).

    \textbf{Frontend (Фронтенд, клиентская часть)} -- Часть веб-приложения или сайта, которую пользователь видит и с которой взаимодействует в своем браузере. Отвечает за представление данных пользователю и обработку пользовательских взаимодействий.

    \textbf{HTTP} -- протокол, используемый для передачи гипертекстовых документов в Интернете.

    \textbf{JSON} -- текстовый формат обмена данными, основанный на JavaScript. Представляет собой набор пар "ключ: значение".

    \textbf{URL} -- строка, используемая для идентификации ресурса в Интернете.

    \textbf{Алерт} -- пользовательское уведомление, информирующее о каком-либо событии.

    \textbf{Аннотация} -- метаданные, позволяющие декларативно влиять на код.

    \textbf{База данных} -- структурированный набор данных для простого взаимодействия пользователя с ними.

    \textbf{Бизнес-логика} -- часть программы, определяющая правила обработки данных. Описывает процессы организации в виде кода.

    \textbf{Класс} -- шаблон для создания объектов. Определяет набор полей и методов, доступных для объекта.

    \textbf{Конечная точка} -- url, на который приложения отправляют запросы для взаимодействия с веб-сервисами.

    \textbf{Массив} -- структура данных, представляющая набор идентифицируемых элементов.

    \textbf{Метод} -- Блок кода, выполняющий конкретную задачу. Используется для организации кода.

    \textbf{Много к одному} -- тип отношения в базе данных, когда несколько записей в одной таблице связаны с одной и той же записью в другой таблице.

    \textbf{Нормализация} -- Процесс организации данных в базе данных, нацеленный на повышение её гибкости и защищённости.

    \textbf{Объект} -- экземпляр класса, то есть созданная и действующая по правилам класса структура.

    \textbf{Один к одному} -- тип отношения в базе данных, когда одна запись в таблице связана не более чем с одной записью в другой таблице.

    \textbf{Окружение} -- набор условий и параметров, в которых выполняется программа. Может включать аппаратное и программное обеспечение, операционные системы, переменные окружения и другие компоненты.

    \textbf{Поле} -- элемент данных, который является частью структуры, как класс или запись в базе данных.

    \textbf{Разрешение экрана} -- количество пикселей, отображаемых на устройстве вывода изображения.

    \textbf{РКИБ} -- ГАУЗ <<Республиканская клиническая инфекционная больница имени Агафонова>>.

    \textbf{Ресурс} -- в контексте API -- единица данных или функциональности, которую можно получить через API, в иных случаях -- любой элемент, который может использоваться программой (файлы, память и так далее).

    \textbf{СУБД} -- комплекс программ, предназначенный для создания, управления и обработки баз данных.

    \textbf{Сущность (Entity)} -- объект, представляющий запись в базе данных.

    \textbf{Технологический стек} -- конкретный набор технологий, используемых для разработки и запуска приложения.

    \textbf{Триггер} -- в контексте базы данных -- специальная процедура, автоматически срабатывающая при заданных событиях.

    \textbf{Фреймворк} -- абстрактная платформа, предоставляющая общую структуру приложения для упрощения разработки.

    \newpage

    \section*{Введение}
    \addcontentsline{toc}{section}{Введение}

        Медицинской отрасли не хватает информатизации. Это устоявшаяся сфера, однако она не соответствует современности: никто не хочет стоять в очередях, вручную заполнять документы, потерять выданный рецепт. В 2018 году Правительство РФ создало национальный проект <<Здравоохранение>>, направленный на улучшение медицины. Одна из задач проекта -- перенос Минздравом в электронный формат части услуг: выдача рецептов, запись к врачу, подача заявления на полис, хранение медицинских документов~\cite{natsproektzdravoohranenie}.

        На деле перевели услуги в электронный формат не везде. В России 30~000 медицинских учреждений и нужно много времени для внедрения системы в каждое из них. При этом нужно учитывать особенности каждого учреждения -- то, что подойдёт больнице в Москве, может не подойти поликлинике из маленького города.

        Одно из учреждений так и не перешедших в электронный формат -- Республиканская клиническая инфекционная больница имени Агафонова (далее РКИБ). Сейчас в неё активно внедряются цифровые технологии, например -- оплата услуг. Но некоторые элементы остаются прежними, в частности, запись на приём. С ней то нам и предстоит разобраться.

        \textbf{Цель:} Информатизировать запись на приём в РКИБ

        \textbf{Задачи:}

        \begin{enumerate}[nolistsep]
            \item Изучить предметную область
            \item Проанализировать существующие аналоги
            \item Составить техническое задание
            \item Спроектировать части будущей системы
            \item Реализовать спроектированные части системы
        \end{enumerate}

        \textbf{Объект исследования:} Информатизация в системе здравоохранения

        \textbf{Предмет исследования:} Запись на приём в медицинское учреждение

        \textbf{Структура:} В первой части работы анализируется предметная область и определяется необходимый функционал. Во второй главе будущая система проектируется, в третьей -- реализуется. Заключительная, четвертая часть -- введение готовой системы в эксплуатацию.

        \newpage

    \section{Предметная область}

    \subsection{Основные сведения}

        РКИБ специализируется на помощи с инфекционными патологиями. Сюда приходят лечиться люди с хроническими заболеваниями и те, кто хочет исследоваться на наличие болезней. Другие поликлиники направляют пациентов в РКИБ, потому что здесь предоставляется большое количество услуг: рентген, диагностика и лечение разных болезней, проведение лабораторных исследований, содержание больных в стационаре.

        В этой больнице нет живых очередей. Каждый пациент записывается на какое-то время и принимается только по записи. Нет ситуаций, когда приходят "Только спросить" или когда требуется неотложная помощь. Этим РКИБ отличается от большинства других поликлиник.

        Врачи сами задают время своего приёма. Они составляют расписание на 2 недели вперёд, но оно может и измениться, например, если врач заболел. Расписание передаётся в регистратуру, где пациентов и записывают на приём.

    \subsection{Существующие решения}

    \subsubsection{Текущее решение проблемы}\label{Текущее решение проблемы}

        На момент начала работы в РКИБ нет никакой информатизированной системы записи на приём. На каждого врача и, иногда, услугу заведена отдельная тетрадь. Пример такой тетради приведён на Рисунке~\ref{fig:Тетрадь на УЗИ+ФС}.

        \begin{figure}[h]

            \centering

            \includegraphics[width=0.8\linewidth]{Пример заполненной тетради на УЗИ+ФС. Чёрным закрашены номера телефонов.png}

            \caption{\centering Пример заполненной тетради на УЗИ+ФС. Чёрным закрашены номера телефонов}

            \label{fig:Тетрадь на УЗИ+ФС}

        \end{figure}

        Пациент, приходя в больницу, иду в регистратуру. Там его вручную записывают в тетрадь на конкретное время к конкретному врачу, вписывают его данные в тетрадь. Далее в указанное время человек приходит к врачу.
        На первый взгляд схема проста и в ней сложно допустить ошибки, но если посмотреть внимательнее, то у неё много недостатков:

        \begin{itemize}[nolistsep]
            \item[--] \textbf{Отсутствие синхронизации.} Если пациент отменил запись, то изменение нужно сделать везде, где было упоминание о приёме.
            \item[--] \textbf{Невозможность копирования.} Каждый врач должен несколько раз в день сверяться с записью к нему, потому что актуальная копия только в регистратуре. При составлении отчётов также требуется переносить сведения о приёме. То есть вручную переписывать сотни строк.
            \item[--] \textbf{Невозможность обработки.} Нужно постараться, чтобы найти данные о пациенте, который приходил месяц назад. Если тетрадь поменялась, то потребуется ещё и находить архивные записи. Восстановить таким образом графики врачей задача тоже не из простых.
            \item[--] \textbf{Дублирование информации.} В РКИБ, по словам сотрудников, много регулярных пациентов. Если кто-то приходит каждый месяц, то в тетрадях он будет записан столько раз, сколько приходил. Редко когда у человека меняется, например, отчество или дата рождения. Эти данные записываются по нескольку раз, хотя это не имеет никакого смысла.
            \item[--] \textbf{Невозможность качественного планирования расписания.} У врачей часто меняется график работы, а в тетради строки фиксированы и ограничены. При любом изменении в графике нужно вручную найти конфликтующие пункты и изменить их.
            \item[--] \textbf{Хранение неактуальной информации.} Человек, поменявший место работы, навсегда в какой-то из тетрадей останется на прошлом.
        \end{itemize}

        Несмотря на недостатки, РКИБ использует этот способ. Всё из-за того, что он прост для понимания, доступен и к нему привыкли. Разработанная в результате система должна быть приближена к этому, чтобы под неё не нужно было долго переучиваться.

    \subsubsection{1С:Медицина}

        <<1С:Медицина>> -- решение от компании 1С. Продуманное, сделанное профессионалами, проверенное временем. Пример интерфейса на Рисунке~\ref{fig:Интерфейс 1С:Медицина}. Это мог бы быть хороший вариант, но у него тоже есть недостатки:

        \begin{itemize}[nolistsep]
            \item[--] \textbf{Отсутствие интеграции с существующими системами.} Несмотря на то, что в РКИБ слабо информатизирована, что-то у неё уже есть. Переход на 1С означает отказ от практически всего разработано ранее, либо дополнительные затраты на интеграцию.
            \item[--] \textbf{Избыточность.} Система нацелена на универсальность, поэтому в ней много функций, не нужных этой больнице, их можно было бы упростить. Сложность системы приводит к сложности её внедрения и обслуживания.
            \item[--] \textbf{Цена и поддержка.} Система стоит не малых денег, а поддержка будет требовать дополнительных вложений. При этом, если верить отзывам из открытых источников, поддержка и документация не всегда могут оперативно помочь.
        \end{itemize}

        \begin{figure}[h]

            \centering

            \includegraphics[width=0.6\linewidth]{Интерфейс 1С:Медицина.png}

            \caption{\centering Интерфейс 1С:Медицина}

            \label{fig:Интерфейс 1С:Медицина}

        \end{figure}

    \subsubsection{Другая предлагавшаяся система}

        Разрабатываемая система -- не первая, которую хотели внедрить в РКИБ. По словам сотрудников, им уже предлагали готовое решение. Проблема в том, что система не была приспособлена к использованию в этой больнице. Она подходила обычной поликлинике, но РКИБ слишком сильно от них отличается. Здесь нет привычных участков. Обслуживаются не только жители ближайших районов, но и, во том числе, других регионов. Это помешало внедрить её в РКИБ.

        Приспособленность к работе в условиях этой конкретной больницы -- важное условие для запуска системы.

    \subsection{Техническое задание}\label{Техническое задание}

        В системе выделяются 4 роли:

        \begin{itemize}[nolistsep]
            \item[--] Пациент. Тот, кто имеет возможность попасть на приём.
            \item[--] Доктор. Принимает пациентов согласно своему расписанию.
            \item[--] Регистратор. Записывает и подтверждает запись к врачу.
            \item[--] Администратор. Имеет доступ ко всем данным для их редактирования в случае возникновения проблем. Управляет редкоизменяемыми данные.
        \end{itemize}

        Каждая из них отличается требуемым функционалом. При этом каждый пользователь может иметь от 1 до 4 ролей, ведь ничто не мешает врачу записаться на приём к другому врачу. Рассмотрим функциональные требования к системе для каждой роли и нефункциональные требования, необходимые системе в целом.

    \newpage

    \subsubsection{Функциональные требования}\label{ТЗ. Функциональные требования}

        Как уже было сказано в пункте~\ref{Техническое задание}, в системе есть 4 роли. Диаграмма вариантов использования для этих ролей представлена на Рисунке~\ref{fig:Диаграмма вариантов использования}. Далее рассмотрим требования для каждой роли подробнее.

        \begin{figure}[h]

            \centering

            \includegraphics[width=0.9\linewidth]{Диаграмма вариантов использования.png}

            \caption{\centering Диаграмма вариантов использования}

            \label{fig:Диаграмма вариантов использования}

        \end{figure}

    \paragraph{Пациент}\label{ТЗ. Пациент}

    Функциональные требования для пациента:

    \begin{itemize}[nolistsep]
        \item[--] \textbf{Авторизация.} На первой странице приложения должна быть авторизация для пациентов. По логину и паролю пациент получает доступ к остальным функциям.
        \item[--] \textbf{Просмотр докторов.} Возможность узнать какие врачи работают в учреждении и какие у них специализации. Нужно для того, чтобы даже если врач болеет, то была информация о нём.
        \item[--] \textbf{Просмотр времени для записи.} Созданный врачом график записи должен отображаться для пользователя там же, где и "Просмотр докторов", но при выборе конкретного доктора.
        \item[--] \textbf{Заявка на запись.} Выбрав время приёма, пользователь может нажать на кнопку "Записаться". Заявка отправляется регистратору и время для записи закрывается. Одновременно активных заявок на приём у пациента может быть не более двух.
        \item[--] \textbf{Отмена заявки на запись.} Если по какой-то причине пациент не может попасть на приём, то на странице своих визитов он может нажать на кнопку "Отменить запись". Сразу после этого время для приёма должно освободиться, а регистратору должно прийти об этом уведомление.
        \item[--] \textbf{Просмотр своих визитов.} Пациент может просмотреть информацию о своих прошлых визитах и о текущих записях с указанием информации об обращении.
        \item[--] \textbf{Уведомления об изменении расписания.} Если получилось так, что пациент не может быть принят в указанное время по причине изменения расписания, то ему должно прийти уведомление об этом.
    \end{itemize}

    \paragraph{Доктор}\label{ТЗ. Доктор}

    Функциональные требования для доктора:

    \begin{itemize}[nolistsep]
        \item[--] \textbf{Авторизация.} На первой странице приложения около панели входа должна быть кнопка для перехода на страницу входа как сотрудника. Отличается он возможностью указать роль в учреждении. После входа под конкретной ролью пользователя переносит на страницу этой роли.
        \item[--] \textbf{Управление своим расписанием.} Возможность создавать новые элементы своего расписания, отмечать недоступными те, в которые врач не сможет совершить приём.
        \item[--] \textbf{Просмотр списка записанных к нему.} Пациенты, которые записались на приём к врачу доступны для быстрого просмотра этому врачу. Если никто не записан на какое-то время, то об этом тоже должно быть написано. Если изменения в расписании касаются текущего рабочего дня, то об изменении в списке приёма дополнительно должно приходить уведомление.
        \item[--] \textbf{Просмотр всех пациентов.} Должна быть возможность доктору просматривать всех пациентов.
        \item[--] \textbf{Заполнение данных о приёме.} Основная информация о приёме не затрагивает текущую систему, однако, должна быть возможность указания диагноза и комментария по приёму.
    \end{itemize}


    \paragraph{Регистратор}\label{ТЗ. Регистратор}

    Функциональные требования для регистратора:

    \begin{itemize}[nolistsep]
        \item[--] \textbf{Авторизация.} То же самое, что авторизация врача.
        \item[--] \textbf{Создание/подтверждение записи пациента.} Регистратор может самостоятельно записать пациента на приём если он, например, пришёл в учреждение. Актуально для пожилых. Для этого регистратор указывает пациента и время приёма. Если же речь о подтверждении, то всё уже указано и требуется только его проверка.
        \item[--] \textbf{Отмена записи на приём.} По каким-либо причинам пациент может не прийти на приём. Если он сообщил об этом заранее, то есть до приёма есть время, то у регистратора есть возможность отменить запись.
        \item[--] \textbf{Уведомления об изменениях в расписании.} Если врач поменял своё расписание, а на эти элементы расписания были записаны пациенты, то регистратору приходит уведомление, что с это нужно обработать дополнительно.
        \item[--] \textbf{Генерация отчётов.} Возможность генерации отчётов за указанный промежуток времени. Отчёты могут быть разные, например, количество приёма по врачам, количество фактического времени приёма для врачей.
    \end{itemize}

    \paragraph{Администратор}\label{ТЗ. Администратор}

    Функциональные требования для администратора:

    \begin{itemize}[nolistsep]
        \item[--] \textbf{Авторизация.} То же самое, что авторизация врача.
        \item[--] \textbf{Управление всеми доступными данными системы.} Должна быть страница для каждого элемента, который вообще можно изменять. Только администратор может менять список услуг, добавлять сотрудников, взаимодействовать со статусами.
        \item[--] \textbf{Генерация отчётов.} То же самое, что генерация отчётов для регистратора.
    \end{itemize}

    \newpage

    \subsubsection{Нефункциональные требования}

    В этом разделе рассмотрим критерии, используемые для оценки работы системы -- характеристики производительности и некоторые атрибуты качества.

    \paragraph{Совместимость}\label{ТЗ. Интерфейс пользователя}

    Система должна корректно работать Chromium, Яндекс.Браузер, Edge версий, актуальных на начало 2023 года. Должна гарантироваться работа на экранах с разрешениями от 1024x768 до 1920x1440 для соотношения сторон 4:3, и с разрешениями 1280x720 до 1920x1080 для соотношения сторон 16:9. Указанные разрешения предполагают развёрнутость окно браузера на полный экран.

    \paragraph{Безопасность}\label{ТЗ. Безопасность}

    Использование системы должно происходить только через HTTPS. Пароли должны храниться в таком виде, чтобы из него было невозможно узнать изначальный пароль. Следовательно, не должно быть возможности восстановить пароль -- только сбросить и создать новый.

    \paragraph{Производительность}\label{ТЗ. Производительность}

    Система должна корректно работать при одновременном подключении как минимум 10 пользователей без значительного снижения производительности -- не более 10 секунд на запрос при условии стабильного подключения интернета 100Мбит/с.

    \pagestyle{plain}

    \newpage

    \section{Проектирование}\label{Проектирование}

    Разрабатываемая система -- клиент-серверное приложение. Простейшая схема клиент-серверного приложения представлена на Рисунке~\ref{fig:Схема клиент-серверного приложения}.

    \begin{figure}[h]

        \centering

        \includegraphics[width=0.8\linewidth]{Схема клиент-серверного приложения.png}

        \caption{\centering Схема клиент-серверного приложения}

        \label{fig:Схема клиент-серверного приложения}

    \end{figure}

    В этой главе займёмся проектированием указанных частей приложения, а в главе~\ref{Реализация} реализуем спроектированные части.

    \subsection{База данных}

    Для реализации системы потребуется база данных. Её цель -- упростить работу с данными для серверной логики. Появляется выбор -- использовать реляционную или нереляционную базу данных.

    Нереляционная база данных, с одной стороны, может повысить гибкость приложение, а с другой -- усложняет работу с данными. В разрабатываемой системе выигрыш от использования нереляционной базы данных минимален, потому что даже в тетрадях всё записывалось в виде простых таблиц. Реляционная база данные в этом случае подойдёт больше -- с ней гораздо проще работать и они лучше подойдут для, например, поиска, потому что список полей фиксирован.

    Выделим список компонентов базы данных исходя из данных в пункте~\ref{Текущее решение проблемы}.

    \subsubsection{Основные компоненты}\label{Проектирование БД. Основные компоненты}

    Для создания схемы данных нужно проанализировать задачу: Система должна позволять связывать заявки людей на приём и время приёма. Получается, что основных компонентов должно быть 2: \textbf{обращение} и \textbf{расписание}. К этому же можно прийти из пункта~\ref{Текущее решение проблемы}: Для каждого обращения в тетради используется отдельная строка. Для расписания врачей тоже используется одна строка на одно время приёма. Простейшая возможная база данных -- простой перенос строк в поля таблиц, получим:

    \begin{itemize}[nolistsep]
        \item[--] \textbf{Обращение:} Содержит данные пациента: ФИО, занятость, адрес для идентификации пациента. Дополнительно содержит направление и диагноз.
        \item[--] \textbf{Расписание:} Включает в себя ФИО врача, услугу, которую он оказывает, время и, опционально, данные об обратившемся человеке. Причём приём может быть сразу на 2 и более ячейки расписания. Связь <<Много к одному>>.
    \end{itemize}

    \subsubsection{Вспомогательные компоненты}\label{Проектирование БД. Вспомогательные компоненты}

    Рассмотрим данные, которые можно было бы вынести в отдельные таблицы, для удобства работы с ними. Дополнительные компоненты можем разделить на 2 категории:

    \begin{itemize}[nolistsep]
        \item[--] Отражающие существующую логику. Они напрямую взяты из тетрадей и понятны обычному человеку.
        \item[--] Упрощающие работу с данными. Нужны только для использования внутри системы.
    \end{itemize}

    \paragraph{Отражающие существующую логику}\label{Проектирование БД. Вспомогательные компоненты. Отражающие логику}

    \begin{itemize}[nolistsep]
        \item[--] \textbf{Пациент:} Хранит информацию о пациенте в общем. Нужна для хранения общей информации о человеке, которая не обязательно должна быть у, например, врача. Так совсем не обязательно врачу указывать свой личный телефон, если он не является одновременно пациентом.
        \item[--] \textbf{Сотрудник:} Нужна только для определения кто из людей какую роль занимает в учреждении.
        \item[--] \textbf{Учреждение:} Если пациент пришёл по направлению, то это направление должен был кто-то выдать.
        \item[--] \textbf{Услуга:} Медицинские учреждения предоставляют конкретный список услуг. Таблица фиксирует эти услуги.
    \end{itemize}

    \paragraph{Упрощающие работу с данными}\label{Проектирование БД. Вспомогательные компоненты. Упрощающие работу с данными}

    \begin{itemize}[nolistsep]
        \item[--] \textbf{Человек:} Сущность, объединяющая пациента и сотрудника. В обеих таблицах есть ФИО. К тому же аккаунт должен быть и у тех, и у тех. Более того, один и тот же человек может быть и пациентом, и сотрудником. Объединение нормализует данные.
        \item[--] \textbf{Статус обращения:} Вспомогательная таблица. Нужна для определения того, что делать с обращением. Например, чтобы отменённое обращение не показывалось в расписании врача.
        \item[--] \textbf{Статус элемента расписания:} Тоже вспомогательная таблица, но для других целей. Например, если врач заболел, то записанные к нему люди будут отдельно обработаны регистратором.
    \end{itemize}

    \subsubsection{Логическая схема данных}

    Исходя из пунктов \ref{Проектирование БД. Основные компоненты} и \ref{Проектирование БД. Вспомогательные компоненты} получаем схему данных, представленную на Рисунке~\ref{fig:Логическая схема данных}.

    \begin{figure}[h]

        \centering

        \includegraphics[width=0.9\linewidth]{Логическая схема данных.png}

        \caption{\centering Логическая схема данных}

        \label{fig:Логическая схема данных}

    \end{figure}

    \newpage

    \subsection{Серверная часть}

    Клиентский код не должен напрямую обращаться к базе данных. Ему нужно промежуточное звено -- сервер. Передавать данные клиент и сервер должны заранее определённым способом -- API. Данные между клиентом и сервером передаются в формате, понятном обоим элементам. После преобразования данных в сущности, сервер работает напрямую с базой данных. Архитектура серверной части представлена на Рисунке~\ref{fig:Архитектура серверной части}

    \begin{figure}[h]

        \centering

        \includegraphics[width=0.9\linewidth]{Архитектура серверной части.png}

        \caption{\centering Общая архитектура серверной части}

        \label{fig:Архитектура серверной части}

    \end{figure}

    \subsubsection{Выбор вида API}

    В зависимости от потребностей системы можно использовать разные виды API. Сравнение популярных видов API представлено в Таблице~\ref{tab:Популярные виды API}.

    \begin{xltabular}{\textwidth} { |
            >{\hsize=0.20\hsize} X |
            >{\hsize=0.40\hsize} X |
            >{\hsize=0.40\hsize} X | }
        \hline
        Название
        & Плюсы
        & Минусы \\
        \hline
        REST
        & -- Простота \newline -- Универсальность \newline -- Поддержка CRUD \newline -- Не сохраняет состояние (легко масштабируется)
        & -- Отсутствие строго стандарта \newline -- Низкая производительность при большом количестве запросов \\
        \hline
        SOAP
        & -- Безопасность \newline -- Поддержка транзакций \newline -- Строгий стандарт
        & -- Большая избыточность данных \newline -- Сложность использования и настройки \\
        \hline
        GraphQL
        & -- Нет избыточных данных \newline -- Возможность сложных запросов \newline -- Сильная типизация
        & -- Сложность разработки \newline -- Сложность масштабирования \newline -- Перегрузка из-за сложности запросов \\
        \hline
        gRPC
        & -- Быстрое выполнение \newline -- Сильная типизация
        & -- Сложность в настройке и использовании \\
        \hline
        JSON-RPC и XML-RPC
        & -- Простота использования и разработки \newline -- Лёгкость интеграции
        & -- Нет поддержки HTTP-методов \newline -- Затруднение масштабирования \\
        \hline

        \caption{\centering Популярные виды API}

        \label{tab:Популярные виды API}
    \end{xltabular}

    Для разработки был выбран REST. Его минусы в рамках проекта незначительны: в системе не будет большого количества запросов, а отсутствие строгого стандарта всего лишь делает его принципы рекомендациями. При этом REST удовлетворяет всем потребностям приложения -- поддержка HTTP-методов, отсутствие сохранения состояния.

    \subsubsection{Авторизация}

    \begin{xltabular}{\textwidth} { |
            >{\hsize=0.20\hsize} X |
            >{\hsize=0.40\hsize} X |
            >{\hsize=0.40\hsize} X | }
        \hline
        Название & Плюсы & Минусы \\
        \hline
        Basic Auth
        & -- Хорошо работает с HTTPS \newline -- Не требует сессий \newline -- Прост в реализации
        & -- Нет средств управления сессиями \newline -- Передача данных в незашифрованном виде \\
        \hline
        Digest Auth
        & -- Безопасность из-за хеширования для передачи данных
        & -- Сложность реализации \newline -- Нет управления сессиями \\
        \hline
        Token-based Auth \newline (JWT, OAuth)
        & -- Есть управление сессиями \newline -- Передача метаданных
        & -- Сложная реализация и управление токенами \newline -- Проблемы при больших объёмах данных \\
        \hline
        Session-based Auth
        & -- Управление сессиями \newline -- Сервер контролирует данные сессии
        & -- Хранение и управление данными сессии \newline -- Плохо масштабируется \\
        \hline

        \caption{\centering Популярные виды API}

        \label{tab:Авторизация}
    \end{xltabular}

    Для данного проекта была выбрана Basic Auth, потому что он прост в реализации. Его проблема безопасности решается использованием HTTPS и он хорошо подходит для проектов небольшого масштаба.

    Заголовок авторизации -- специальная строка, передающаяся вместе с запросом. Выглядеть строка должна так: <<Authorization: Basic *токен*>>, где *токен* -- Это зашифрованная с помощью Base64 строка вида <<*логин*:*пароль*>>. При запуске приложения создаётся аккаунт по умолчанию, поэтому для всех методов, кроме установки пароля, потребуется авторизация.

    \subsubsection{Методы API}

    Каждый запрос на сервер в разрабатываемой системе характеризуется несколькими параметрами:

    \begin{itemize}[nolistsep]
        \item[--] URL
        \item[--] Метод HTTP
        \item[--] Заголовок авторизации
        \item[--] Параметры в теле запроса, либо в URL
    \end{itemize}

    Зная эти данные мы можем дать нужный ответ. Теперь нужно определить -- кто к каким конечным точкам должен иметь доступ. Для этого нужно составлять таблицы с указанием приведённых выше параметров. Поскольку полное расписывание API займёт очень много места, здесь будет приведён сокращённый вариант -- без тел запроса. Подробный вариант можно найти в приложении.

    Хорошей практикой считается разделение версий API и выделение его в URL. Поэтому перед каждой конечной точкой в реальных запросах к API дополнительно используется /api/v1, если не сказано иное. Спроектированные методы API представлены в Таблице~\ref{tab:Методы API}

    \begin{xltabular}{\textwidth} { |
        >{\hsize=0.25\hsize} X |
        >{\hsize=0.20\hsize} X |
        >{\hsize=0.55\hsize} X | }

        \hline
        URL & HTTP метод & Краткое описание \\

        \hline
        /people/\{id\}
        & GET, PUT, DELETE
        & Получение, изменение, удаление общих данных о человеке \\

        \hline
        /people/me
        & PUT, GET
        & Получение, изменение данных о себе \\

        \hline
        /people
        & POST, GET
        & Получение списка всех пользователей \\

        \hline
        /patients/\{id\}
        & GET, PUT, DELETE
        & Получение, изменение, удаление пациента \\

        \hline
        /patients
        & POST, GET
        & Получение списка всех пациентов \\

        \hline
        /employees/\{id\}
        & GET, PUT, DELETE
        & Получение, изменение, удаление сотрудника \\

        \hline
        /employees
        & POST, GET
        & Получение списка всех сотрудников \\

        \hline
        /institutions/\{id\}
        & GET, PUT, DELETE
        & Получение, изменение, удаление учреждения  \\

        \hline
        /institutions
        & POST, GET
        & Получение списка всех учреждений \\

        \hline
        /appointments/\{id\}
        & GET, PUT, DELETE
        & Получение, изменение, удаление обращения \\

        \hline
        /appointments
        & POST, GET
        & Получение списка всех обращений \\

        \hline
        /schedules/\{id\}
        & GET, PUT, DELETE
        & Получение, изменение, удаление элемента графика \\

        \hline
        /schedules
        & POST, GET
        & Получение списка всех элементов графика \\

        \hline

        \caption{\centering Методы API}

        \label{tab:Методы API}
    \end{xltabular}

    Отдельно стоит выделить таблицы, к которым должен иметь доступ только администратор. Это такие таблицы, которые меняются очень редко и их изменение сильно влияет на всю систему. Например, изменение в таблице <<Услуги>>. Перечень запросов, доступных только Администратору представлен в Таблице~\ref{tab:Методы API только для Администатора}.

    \begin{xltabular}{\textwidth} { |
        >{\hsize=0.34\hsize} X |
        >{\hsize=0.18\hsize} X |
        >{\hsize=0.47\hsize} X | }

        \hline
        URL
        & HTTP метод
        & Краткое описание \\

        \hline
        /procedures/\{id\}
        & GET, PUT, DELETE
        & Получение, изменение, удаление услуги \\

        \hline
        /procedures
        & POST, GET
        & Добавление услуги, получение всех услуг \\

        \hline
        /appointmentStatuses/\{id\}
        & GET, PUT, DELETE
        & Получение, изменение, удаление статуса обращения \\

        \hline
        /appointmentStatuses
        & POST, GET
        & Добавление статуса обращения, получение всех статусов обращений \\

        \hline
        /scheduleStatuses/\{id\}
        & GET, PUT, DELETE
        & Получение, изменение, удаление статуса элемента графика \\

        \hline
        /scheduleStatuses
        & POST, GET
        & Добавление статуса элемента графика, получение всех статусов элементов графика \\

        \hline

        \caption{\centering Методы API только для Администратора}

        \label{tab:Методы API только для Администатора}
    \end{xltabular}

    \subsubsection{Обработка ошибок}\label{Проектирование сервера. Обработка ошибок}

    Обработку ошибок можно разделить на 2 больших пункта:

    \begin{itemize}[nolistsep]
        \item[--] На стороне сервера. Рассматривается в этом пункте
        \item[--] На стороне клиента. Будет рассматриваться в пункте~\ref{Проектирование клиента. Обработка ошибок}
    \end{itemize}

    \paragraph{Обработка ошибок базы данных}

    Отдельно выделяются ошибки, связанные с базой данных. Это такие ошибки, которые может быть сложно, либо затратно обнаружить и обработать. Это связано с тем, что база данных -- отдельная часть системы, с которой взаимодействует сервер. Есть несколько основных моментов, которые стоит затронуть:

    \begin{itemize}[nolistsep]
        \item[--] \textbf{Транзакционность.} База данных хранит данные -- это её основная задача. Контроль корректности вводимых данных на её стороне возможен либо частичный (ограничиваясь, например, уникальностью полей), либо очень затратен в создании и поддержке (триггеры). Если данные записались в базу данных, то может быть проблемой удалить их. Особенно это актуально при одновременном создании множества объектов, когда может выполниться только часть запросов. В таких случаях помогает транзакционность -- возможность отменить все изменения в рамках связанных запросов. В рамках разрабатываемой системы необходимо учитывать это на стороне сервера.
        \item[--] \textbf{Определение конкретного места ошибки.} Стандартные ошибки, выдаваемые базой данных, не всегда информативны для пользователя, а иногда и для администратора. Так, например, нарушение связи один к одному, либо конфликт из-за уникальности -- разные ошибки и их нужно по-разному идентифицировать.
    \end{itemize}

    \paragraph{Коды ошибок}\label{Проектирование сервера. Коды ошибок}

    Сопоставление каждой возможной ошибке конкретного кода может значительно ускорить процесс её обработки. Невозможно заранее знать все возможные причины ошибок -- тогда бы их просто не было. Но вполне осуществимо выявление части программы, в которой произошла ошибка. Например, есть код, отвечающий за чтение Person из базы данных. Если мы пометим эту часть кода как вызывающую ошибку с кодом drp-01, то при её возникновении заранее будет известно её расположение. Конечно, это не отменяет вспомогательных сообщений и логирования -- лишь помогает им. Список определённых кодов ошибок достаточно большой, их список приведён в Приложении~\{TODO\}.

    \paragraph{Единый формат ошибок}\label{Единый формат ошибок}

    Стандартные форматы ошибок могут отличаться от фреймворка к фреймворку, что уменьшает гибкость приложения. Дополнительно, не каждый формат ошибок подходит для каждого приложения -- в некоторых много избыточной информации, в некоторых её недостаточно. Поэтому для приложения был разработан единый формат ошибок, использующий JSON. Представлен на Листинге~\ref{errformat}.

    \begin{lstlisting}[label=errformat,caption=Формат ошибок]
    {
        httpCode: "",
        errors: [
            {
                code: "",
                message: "",
                details: ""
            },
            ...
        ]
    }
    \end{lstlisting}

    Разберём по частям:

    \begin{itemize}[nolistsep]
        \item[--] \textbf{httpCode.} У протокола http есть перечень поддерживаемых кодов состояния. Например, коды 2XX -- коды успешного выполнения запроса, 4XX -- ошибки клиента, 5XX -- ошибки сервера. Это общепринятые заданные стандартом коды. Здесь потребуются только коды, отвечающие за ошибки. Явное указание кода в ответе упрощает работу с ошибкой при отладке.
        \item[--] \textbf{errors.} Массив ошибок. Перечень того, что сервер в процессе обработки запроса посчитал некорректным. Стоит отметить, что перечисляются не все ошибки, а лишь те, до которых сервер обработал данные. Несколько элементов может быть указано только если ошибки одного типа, например, все касаются валидации полей.
        \begin{itemize}[nolistsep]
            \item[--] \textbf{code.} Внутренний код ошибки системы, определённый в пункте~\ref{Проектирование сервера. Коды ошибок}.
            \item[--] \textbf{message.} Написанное доступным простому пользователю языком сообщение об ошибке, выводимое на экран.
            \item[--] \textbf{details.} Более развёрнутое сообщение об ошибке, содержащее максимум данных для отладки. Опциональное поле.
        \end{itemize}
    \end{itemize}

    Использование этого стандарта гарантирует, что даже при переходе на другой фреймворк одной из частей приложения, изменения коснутся только её. Иначе в зависимости от фреймворка нужно было бы либо приводить вид одного к другому, либо переделывать и клиентскую, и серверную части.

    \newpage

    \subsection{Клиентская часть}

    Клиентская часть завершает список необходимых компонентов для клиент-серверного приложения. Это та часть, которую пользователь видит на экране. Сюда, по большей части, относится графический интерфейс и работа с ним. Сюда же входит работа с API сервера: формирование запросов, обработка ответов.

    \subsubsection{Архитектура клиентского приложения}

    Для разработки понадобятся различные компоненты, такие как диалоговые окна, кнопки, элементы для поиска элементов. Рассмотрим, какие компоненты нужны для работы системы:

    \textbf{Поля ввода.} На первый взгляд, это один компонент. Но для удобной работы нужно детализировать его для разных нужд:

    \begin{itemize}[nolistsep]
        \item[--] Обычные поля, не требующие особого подхода. Например, комментарий к обращению может быть написан в свободной форме.
        \item[--] Пароль. Требует сокрытия вводимых данных.
        \item[--] Поля со строго определённой структурой. Необходимы для, например, наглядного ввода номера телефона
    \end{itemize}

    Кроме того, большинство полей в базе данных приложения требуют гарантии заполненности. Так услуга не имеет смысла без её названия. Нужна возможность визуальных подсказок для полей.

    \textbf{Алерты.} Компоненты, информирующие пользователя о событиях. Когда на странице не могут загрузиться данные, либо произошла какая-то ещё ошибка, то нужно об этом сказать пользователю. Для этого хорошо подходит отдельный компонент.

    \textbf{Выпадающие списки.} Заменяют поля ввода, когда список его значений заранее известен и достаточно мал.

    \textbf{Диалоговые окна.} Это элементы, появляющиеся поверх основной страницы и служащие для совершения какого-то фиксированного действия. Например, отправка запроса на создание элемента или выбор элемента из множества на основе фильтров. В разделе~\ref{Техническое задание} упоминалось, что в системе будет Администратор. Он должен иметь возможность редактировать все записи в базе данных. Для этого ему потребуется диалоговое окно на каждую из сущностей. Они же будут использоваться и для остальных ролей в случаях, когда доступ к сущностям есть.

    \subsubsection{Проектирование интерфейса пользователя}

    В пункте~\ref{Техническое задание} выделено 4 роли: Пациент, доктор, регистратор, администратор. У каждого из них, в соответствии с пунктами~\ref{ТЗ. Пациент}~--~\ref{ТЗ. Администратор} в системе свои возможности. Для этого необходимо разграничение интерфейса. Роли с указанием доступных им страниц представлены в Таблице~\ref{tab:Роли в системе и доступные им страницы}

    \begin{xltabular}{\textwidth} { |
        >{\hsize=0.30\hsize} X |
        >{\hsize=0.70\hsize} X | }

        \hline
        Роль
        & Доступные страницы \\

        \hline
        Пациент
        & -- Просмотр расписания врача \newline -- Подача заявки на приём \\

        \hline
        Доктор
        & -- Запись к себе \newline -- Создание своего расписания \newline -- Просмотр расписаний других врачей \\

        \hline
        Регистратор
        & -- Расписания врачей \newline -- Пациенты \\

        \hline
        Администратор
        & -- Страницы с доступом для редактирования для каждой сущности \\

        \hline

        \caption{\centering Роли системы и доступные им страницы}

        \label{tab:Роли в системе и доступные им страницы}
    \end{xltabular}

    \subsubsection{Обработка ошибок}\label{Проектирование клиента. Обработка ошибок}

    Важная часть разработки клиентского приложения -- правильная обработка ошибок. Она помогает предотвратить прерывание работы приложения, выявить и устранить причину ошибок. Продуманная система обработки ошибок важна для стабильности приложения.

    Существуют разные виды ошибок, которые должно обрабатывать клиентская сторона, например:

    \begin{itemize}[nolistsep]
        \item[--] Обработка ошибок на уровне приложения
        \item[--] Ошибки, генерируемые сервером. Например, запрос недоступного пользователю ресурса
        \item[--] Некорректный ввод пользователя. Частично относится к прошлому пункту, но выделение позволяет сделать интерфейс удобнее
        \item[--] Недоступность сервера
    \end{itemize}

    Подробнее рассмотрим важные элементы обработки ошибок

    \paragraph{Валидация данных}\label{Проектирование клиента. Валидация данных}

    Для предотвращения ошибок, связанных с неверными данными, в приложении необходимы механизмы проверки ввода -- валидации. Это включает валидацию свойств компонентов, использование библиотек для валидации форм и других пользовательских данных посредством специальных заранее определённых правил.

    \paragraph{Логирование ошибок}

    Для упрощения отладки и мониторинга работы приложения необходимо использовать систему логирования ошибок. Она включает вывод и сохранение информации об ошибках, отправку данных об ошибках на сервер. Важно одновременно и уведомлять пользователя об ошибках, и сохранять данные о них, поскольку это разные уровни взаимодействия. Первые события рассчитаны больше на пояснение того, что случилось, в понятной простому человеку форме, а вторые -- на то, что их будет разбирать специалист, для чего нужно сохранять больше информации.

    \paragraph{Обработка ошибок в пользовательском интерфейсе}

    Информативные сообщения об ошибках и уведомлениях в пользовательском интерфейсе улучшают пользовательский опыт. Основная реализация -- всплывающие подсказки и уведомления. Стоит затронуть и необходимость визуального выделения ошибок, касающихся валидаций данных из пункта~\ref{Проектирование клиента. Валидация данных}.

    \newpage

    \section{Реализация}\label{Реализация}

    После анализа предметной области и проектирования остаётся последний большой шаг -- реализация. Потребуется написать код всех частей системы, сделать так, чтобы они работали вместе и без ошибок. Важным аспектом является тестирование, которое должно проводиться на протяжении всей разработки системы и даже до неё -- подход <<Разработка через тестирование>>

    \subsection{Выбор технологий}\label{Реализация. Выбор}

    Выбор инструментов реализации проводится параллельно с проектированием. Это начальный этап разработки, который может определять структуру системы. В пункте~\ref{Проектирование} указано, что частей системы 3: база данный, серверная и клиентские части. Рассмотрим реализацию каждой из них ниже. Отдельно стоит упомянуть технологию изоляции приложений, которую будет использовать каждая из частей -- Docker.

    \subsubsection{Развёртывание}\label{Реализация. Выбор. Докер}

    Docker -- специальное средство, позволяющее создавать изолированное окружение для приложения. Это обеспечивает одинаковую работу на любом устройстве, где приложение будет запущено. Основной файл конфигурации -- Dockerfile. Он содержит необходимые настройки для работы приложения. Пример такого файла конфигурации для серверной части приведён на Листинге~\ref{dockerfileback}.

    \begin{lstlisting}[label=dockerfileback,caption=Пример Dockerfile для бекенда]
    FROM openjdk:17
    ARG JAR_FILE=build/libs/*.jar
    RUN mkdir /opt/rkib-back
    COPY ${JAR_FILE} /opt/rkib-back/rkib-back.jar
    ENTRYPOINT ["java","-jar","/opt/rkib-back/rkib-back.jar"]
    \end{lstlisting}

    С помощью этого файла конфигурации уже можно запускать приложение в изолированной среде. Есть ещё один инструмент, помогающий в работе с контейнерами -- docker-compose. Он помогает в организации нескольких контейнеров, если они должны быть запущены вместе. Также позволяет писать удобочитаемый файл конфигурации. Пример такого файла конфигурации -- docker-compose.yml представлен на Листинге~\ref{docker-composeyml}. Теперь для полного разворачивания приложения достаточно одной команды в директории с этим файлом -- "docker-compose~up~-d".

    \begin{lstlisting}[label=docker-composeyml,caption=Пример файла конфигурации docker-compose.yml]
    version: "3.9"
    services:
        rkib-back:
            image: zalimannard/rkib-back:latest
            container_name: rkib-back
            ports:
            - 8116:8116
            depends_on:
            - rkib-database
            environment:
            - DB_URL=*database url*
            - DB_USER=*database user username*
            - DB_PASSWORD=*database user password*
            - DDL_BEHAVIOUR=*what happens to the database*
            - ADMIN_USERNAME=*back's admin username*
            - ADMIN_PASSWORD=*back's admin password*
    \end{lstlisting}

    \subsubsection{База данных}\label{Реализация. Выбор. База данных}

    Изначальное условие для системы было -- использование СУБД Oracle. Если разработанная система будет внедряться, то чтобы не было конфликтов в базе данных. Потому что разные СУБД имеют разные ограничения на имена, например, на длину и зарезервированные слова. Забегая вперёд -- вся работа с базой данных будет через спецификацию JPA, то есть смена СУБД почти не потребует затрат.

    \newpage

    \subsubsection{Серверная часть}\label{Реализация. Выбор. Серверная часть}

    При выборе технологического стека для серверной части важно учитывать такие требования, как производительность, стабильность, безопасность, масштабируемость. Сравнение основных стеков представлено в Таблице~\ref{tab:Сравнение технологических стеков для серверной части}.

    \begin{xltabular}{\textwidth} { |
        >{\hsize=0.30\hsize} X |
        >{\hsize=0.70\hsize} X | }

        \hline
        Состав стека
        & Особенности \\

        \hline
        Java + Spring
        & -- Высокая производительность и скорость выполнения \newline -- Хорошая интеграция с Oracle Database \newline -- Богатый набор библиотек для различных задач \newline -- Строгая статическая типизация для повышения надежности кода \newline -- Многопоточная модель, подходящая для CPU-интенсивных операций и масштабируемых систем \\

        \hline
        Python + Django
        & -- Скорость разработки \newline -- Много функций "из коробки" \newline -- Динамическая типизация \newline -- Меньшая производительность по сравнению с Java \newline -- Интеграция с Oracle может быть менее гибкой \\

        \hline
        JavaScript + Node.js
        & -- JavaScript на сервере и клиенте, упрощает разработку \newline -- Однопоточная модель с асинхронной I/O, эффективной для обработки большого количества коротких запросов \newline -- Низкая производительность для CPU-интенсивных операций по сравнению с Java \newline -- Динамическая типизация и возможные проблемы безопасности \\

        \hline

        \caption{\centering Сравнение технологических стеков для серверной части}

        \label{tab:Сравнение технологических стеков для серверной части}
    \end{xltabular}

    Для представления API в удобном виде будет использоваться \textbf{Swagger}. Он обеспечивает автоматическую генерацию документации по API с возможностью запуска команд из него же. Удобный инструмент для тестирования в процессе разработки.

    Для автотестов будет использоваться \textbf{RestAssured} для запросов на сервер, \textbf{JUnit5} для организации тестов, \textbf{AssertJ} для повышения читаемости тестов и \textbf{Allure} для визуализации результатов тестирования. Они помогают быстро находить проблемы в коде и увеличивают эффективность рефакторинга.

    \textbf{Lombok} -- библиотека для Java, позволяющая сосредотачиваться на написании бизнес-логики, а не на написании шаблонного кода. Так, практически пропадает необходимость написания геттеров, сеттеров, конструкторов и прочих компонентов. Код становится более чистым и легко поддерживаемым.

    \subsubsection{Клиентская часть}\label{Реализация. Выбор. Клиентская часть}

    У клиентский части приложения большое количество нюансов, которые нужно учесть. Они связаны с тем, что этот код будет выполняться на разных компьютерах и нужно обеспечить корректную работу на них.

    Основной язык разработки -- JavaScript. TypeScript -- разработанный компанией Microsoft язык, расширяющий возможности TypeScript: обладает статической типизацией, поддержкой полноценных классов. К тому же он совместим с JavaScript. Он повышает читаемость кода, его повторное использование и скорость поиска ошибок.

    JavaScript отвечает за внутреннюю логику, за внешний вид отвечает HTML и CSS. Можно писать код используя только их, но такой подход хорош только для очень маленьких приложений. Так, работу на разных экранах придётся обеспечивать вручную. Как и следить за цветовой палитрой, стилями и анимацией. Гораздо удобнее использовать фреймворки, так как они представляют готовый набор стандартных элементов и логики. Популярных фреймворка 3:

        \begin{itemize}[nolistsep]
        \item[--] \textbf{React.} Гибкий, с большим количеством библиотек, но для полноценной разработки именно потребуется использование сторонних библиотек, что может быть затруднением.
        \item[--] \textbf{Angular.} Большой фреймворк со всеми нужными компонентами из коробки, чёткая структура, но сложный для изучения и малопроизводительный.
        \item[--] \textbf{Vue.js.} Гибкий, самодостаточный фреймворк с возможностью интеграции со сторонними библиотеками. Прост в освоении, хорошая документация, но меньше материала по сравнению с другими.
    \end{itemize}

    С Vue.js я работал и это, пожалуй, лучший выбор для данной системы. Приложению не нужны супермасштабы и встроенных инструментов хватит для разработки приложения.

    \subsection{База данных}\label{Реализация. База данных}

    Как уже было сказано в пункте~\ref{Реализация. Выбор. База данных}, база данных будет создана через JPA. Это спецификация, обеспечивающая переносимость данных между реляционными базами данных для приложений на Java. В файле конфигурации указано, как поступать с базой данных при каждом запуске приложения. Это указано в файле конфигурации, описанном в пункте~\ref{Реализация. Выбор. Докер}. За это отвечает параметр {DDL\_BEHAVIOUR}. Если требуемая база данных отличается от существующей, то в существующую вносятся необходимые изменения.

    Таблицы и поля в базе данных создаются с помощью JPA, то есть объекту в базе данных соответствует объект в Java. Это позволяет работать с хранящимися данными так, будто они уже являются объектами в Java~\cite{baeldungbook}. Это уже часть пункта~\ref{Реализация. Серверная часть}, но его необходимо разобрать отдельно. Это некая прослойка между СУБД и сервером. Для примера возьмём сущность Patient, описанную как Пациент в логической схеме данных на Рисунке~\ref{fig:Логическая схема данных}. Код представлен в Листинге~\ref{jpapatient}. По порядку разберём написанное:

    Строки 1-2 -- аннотации JPA, отвечающие за создание таблицы в базе данных. @Entity говорит, что класс является объектом базы данных, @Table указывает конкретное название таблицы в базе данных.

    Строки 3-7 -- аннотации библиотеки Lombok. Создают геттеры и сеттеры (методы для доступа к полям), реализует шаблон строитель (позволяет гибко создавать объекты) и генерирует 2 конструктора -- с требуемыми параметрами и всеми. Это нужно для инъекции зависимости, используемой в Spring и для работы шаблона строитель. Дополнительно опущены методы .equals() и hashcode, который сравнивает 2 экземпляра одного класса по заданным параметрам. В этом случае -- сравнение по полю id, так как в базе данных гарантируется уникальность первичного ключа.

    Все остальные таблицы делаются по аналогии, схема данных представлена на Рисунке~\ref{fig:Логическая схема данных}.

    \newpage

    \begin{lstlisting}[label=jpapatient,caption=Пример реализации таблицы Patient через JPA]
    @Entity
    @Table(name = "patients")
    @Getter
    @Setter
    @Builder(toBuilder = true)
    @RequiredArgsConstructor
    @AllArgsConstructor
    public class Patient {
        @Id
        @GeneratedValue(strategy = GenerationType.UUID)
        @Column(name = "id")
        private String id;
        @OneToOne
        @JoinColumn(name = "person_id", referencedColumnName = "id", nullable = false)
        private Person person;

        @Column(name = "birthdate")
        LocalDate birthdate;
        @Column(name = "phoneNumber", nullable = false)
        private String phoneNumber;
        @Column(name = "address")
        private String address;
        @Column(name = "occupation")
        private String occupation;
    }
    \end{lstlisting}

    В строках 9-12 объявляется первичный ключ и его тип генерации -- UUID. Есть разные способы генерации первичного ключа -- по последовательности, автоувеличением значения, какой-либо строкой, либо можно написать вообще свою функцию генерации. Одно из изначальных ограничений системы -- использование строкового первичного ключа. UUID подходит под эту роль. Это способ генерации уникальной последовательности, из-за чего сложно угадать его соседние элементы, что более безопасно, чем другие способы. Распространённая практика делать поле id в каждой таблице.

    В сторках 13-15 указано, что таблицы Person и Patient имеют связь <<Один к одному>>, то есть одному пациенту соответствует один аккаунт. Содержится ссылка и то, что пациент гарантировано имеет аккаунт.

    Строки 17-18 содержат информацию о дате рождения. Дата всегда сложный элемент, потому что, например, часовой пояс не должен влиять на дату рождения. У даты рождения не должно быть времени вообще. LocalDate позволяет гибко работать с датой.

    Далее в строках 17-24 содержатся обычные текстовые поля, характерные для таблицы пациент. Указывается имя и то, что это обычное поле в базе данных.

    Компонент Patient полностью покрывает все нюансы базы данных в создаваемой системе, кроме перечислений, которые будут рассмотрены в пункте~\ref{Реализация. Серверная часть}. Все остальные таблицы делаются по аналогии с этой. При запуске приложения все таблицы автоматически создадутся и свяжутся. Всё это происходит через обычные запросы к базе данных, но автоматически, через обёртку JPA.

    \subsection{Серверная часть}\label{Реализация. Серверная часть}

    Следующий этап -- разработка серверной части. Нужно сделать приложение на Java+Spring используя REST API.

    \subsubsection{Структура проекта}

    Сначала рассмотри структуру файлов, она представлена на Листинге~\ref{backendprojectstructure}. Два важных файла вынесены на самый верх структуры -- главный файл приложения RkibAppointmentBackendApplication, содержащий только метод main с запуском Spring.
    
    Пакет config содержит файлы конфигурации безопасности, он будет рассмотрен в пункте~\ref{Реализация. Сервер. Безопасность}. Validator содержит только файл с указанием шаблона для номера. Его использование будет продемонстрировано в пункте~\ref{Реализация. Сервер. Архитектура слоёв}.

    \begin{lstlisting}[label=backendprojectstructure,caption=Структура серверного приложения]
    RkibAppointmentBackendApplication.java
    schema/
        appointment/
            status/
        institution/
        person/
            employees/
            patient/
        procedures/
        schedule/
            status/
    config/
    exception/
    validator
    \end{lstlisting}
    
    Пакет exception содержит реализацию ошибок, спроектированных в пункте~\ref{Единый формат ошибок}. Приложение может выдавать ошибки с кодами 400 -- неверный запрос, 401 -- неавторизованный запрос, 403 -- нет доступа, 404 -- не найдено, 409 -- конфликт. Причём ошибки 401 и 403 может генерировать сам Spring (конкретно -- Spring Security). Нужно перехватывать эти ошибки, это делается с помощью класса с аннотацией @ControllerAdvice, перехватывающим конкретные ошибки Spring Security, например, валидацию. Код части этого класса приведён на Листинге~\ref{validationadvice}.
    
    \begin{lstlisting}[label=validationadvice,caption=Класс-прехватчик ошибок Spring]
    @ControllerAdvice
    public class ValidationAdvice {
        @ResponseBody
        @ExceptionHandler(ConstraintViolationException.class)
        @ResponseStatus(HttpStatus.BAD_REQUEST)
        public ExceptionResponse onConstraintValidationException(
        ConstraintViolationException e
        ) {
            List<ExceptionMessage> errors = e.getConstraintViolations().stream().map(
            violation -> ExceptionMessage.builder()
            .message(violation.getMessage())
            .details(violation.getPropertyPath().toString()).build()
            ).toList();
            return ExceptionResponse.builder()
            .httpCode(HttpCodes.BAD_REQUEST.getCode())
            .errors(errors)
            .build();
        }
        ...
    }
    \end{lstlisting}
    
    Указывается конкретный тип перехватываемой ошибки, далее формируется ошибка в заданном для системы формате и вместо стандартной ошибки Spring на запрос возвращается она.
    
    Основное приложение находится в schema -- описание сущностей и работы с ними. Разделение -- по логическим единицам, таким как Учреждение, Человек. При этом Пациент и Сотрудник вложены в пакет Человек, а статус вложен в то, статусом чего он является. В каждом из пакетов содержатся файле, которые соответствуют архитектуре слоёв, которая будет рассмотрена далее в пункте~\ref{Реализация. Сервер. Архитектура слоёв}.

    \subsubsection{Архитектура слоёв}\label{Реализация. Сервер. Архитектура слоёв}
    
    Архитектура слоёв -- подход к проектированию, где функциональность разделяется на отдельные слои. Каждый слой изолирует свою логику. Архитектура сервера представлена на Рисунке~\ref{fig:Схема работы сервера}.
    
    \begin{figure}[h]
        
        \centering
        
        \includegraphics[width=0.9\linewidth]{Схема работы сервера.png}
        
        \caption{\centering Архитектура слоёв сервера}
        
        \label{fig:Схема работы сервера}
        
    \end{figure}
    
    Здесь изображено разделение логики на слои представления (Controller), бизнес-логики(Service и Mapper), доступа к данным (Repository). Отображено, какими объектами они обмениваются. Далее рассмотрим каждый из компонентов подробнее. Один из компонентов -- Entity уже был рассмотрен в пункте~\ref{Реализация. Выбор. База данных}
    
    \paragraph{DTO}\label{Реализация. Сервер. DTO}
    
    Клиент и сервер обмениваются данными через HTTP-запросы. В теле запросов передаётся информация в формате JSON, которая должна преобразовываться во внутренний объект сервера -- DTO (объект передачи данных) в Entity. 
    
    Возникает проблема, когда запрос и ответ должны иметь разную структуру. Так, неразумно возвращать пароль пользователю. Да, можно его убирать перед отправкой, но надёжнее вообще не давать возможности отправить нежелательные данные. Также если в теле ответа нужно возвращать дополнительные данные, то им вовсе не обязательно быть в теле запроса. Поэтому DTO дополнительно разделяется на DTO для запросов и DTO для ответов. Сравнение этих двух типов DTO для  представлено в Таблице~\ref{tab:Сравнение объектов передачи данных для запроса и ответа}.
    
        \begin{xltabular}{\textwidth} { |
            >{\hsize=0.50\hsize} X |
            >{\hsize=0.50\hsize} X | }
        
        \hline
        Тело запроса
        & Тело ответа \\
        
        \hline
        -- username \newline -- password * \newline -- lastName \newline -- firstName \newline -- patronymic
        & -- id * \newline -- username \newline -- lastName \newline -- firstName \newline -- patronymic \newline -- patient * \newline -- employee * \\
        
        \hline
        
        \caption{\centering Сравнение объектов передачи данных для запроса и ответа}
        
        \label{tab:Сравнение объектов передачи данных для запроса и ответа}
    \end{xltabular}
    
    Символом <<*>> отмечены отличающиеся элементы. Здесь это значит, что password не будет возвращён в ответе. При этом будет добавится id -- первичный ключ в базе данных, служащий идентификатором. С его помощью можно делать запросы конкретно с этим элементом. Далее появляются patient и employee. С обеими из таблиц Пациент и Сотрудник у таблицы Человек связь один к одному. Если человек является сотрудником, то для него будет дополнительно вложен объект такой, будто запросили информацию не просто о человеке, а о нём как сотруднике. Это уменьшает количество запросов и упрощает работу с данными.
    
    Оба типа DTO используются только для "общения" клиента и сервера и при первой же возможности заменяются на внутренние объекты -- это увеличивает гибкость системы.
    
    Важным аспектом DTO является валидация. Это проверка того, что данные удовлетворяют ограничениям. Ранее мы затронули самописную аннотацию @Phone. Это пример того, как декларативно можно поставить ограничение на значение поля. Использование аннотаций валидации выглядит как показано на листинге~\ref{validation}
    
    \begin{lstlisting}[label=validation,caption=Пример валидации]
    @NotNull(message = "Phone number not specified")
    @Phone(message = "Invalid phone number")
    String phoneNumber;
    \end{lstlisting}
    
    При невыполнении какого-то правила возникает ошибка с определённым сообщением. Перехват таких ошибок был реализован в Листинге~\ref{validationadvice}. Стоит заметить, что для работы валидации необходимо дополнительно указывать аннотацию @Validated на классе и @Valid на объекте, к которому применяется валидация. Так же она может проводиться и для других параметров, не обязательно в теле запроса.
    
    \paragraph{Controller}\label{Реализация. Сервер. Controller}
    
    Служит для связи клиента и сервера. В нём определяется url для получения ресурса и через необходимые параметры и тело в виде DTO он однозначно может передать запрос дальше по системе. Его единственная задача -- определять API. На этом его ответственность заканчивается и через соответствие метода в контроллере и дальше работает слой сервисов (бизнес-логики). Пример кода такого класса с двумя из методов представлен на Листинге~\ref{employeecontroller}.
    
    \begin{lstlisting}[label=employeecontroller,caption=Пример класса слоя представления]
    @RestController
    @RequestMapping("${application.baseApi}${application.apiV1}${application.endpoint.employees}")
    @Tag(name = "Employee")
    @RequiredArgsConstructor
    public class EmployeeController {
        private final EmployeeService employeeService;
        @GetMapping("{id}")
        @Operation(summary = "Get an employee")
        public EmployeeResponseDto get(@PathVariable String id) {
            return employeeService.read(id);
        }
        @GetMapping("${application.endpoint.me}")
        @Operation(summary = "Employee gets himself")
        public EmployeeResponseDto getMe() {
            return employeeService.readMe();
        ...
    }
    \end{lstlisting}
    
    Аннотации @Tag и @Operation относятся к автодокументированию кода, это будет рассмотрено в пункте~\ref{Реализация. Сервер. Документация}. Остальные аннотации, кроме уже рассмотренного конструктора относятся к Spring. Они определяют путь и методы запроса. Единственная строка в методе -- вызов соответствующего метода слоя бизнес-логики.
    
    \paragraph{Service}\label{Реализация. Сервер. Service}
    
    Слой бизнес-логики. На этом слое запросы уже обрабатываются и формируется ответ. Состоит, как правило, из двух компонентов -- интерфейса и его реализации, так выполняются принципы SOLID, инкапсуляции, улучшается тестируемость.
    
    Как показано на Рисунке~\ref{fig:Схема работы сервера}, элементы сервисного слоя могут передавать данные между друг другом. Для этого в классах помимо методов, возвращающих DTO должны быть методы, возвращающие сущности. Пример такого класса приведён на Листинге~\ref{service}
   
   \begin{lstlisting}[label=service,caption=Пример класса слоя бизнес-логики]
    @Service
    @RequiredArgsConstructor
    public class PatientServiceImpl implements PatientService {
        
        private final PatientMapper mapper;
        private final PatientRepository repository;
        @Override
        public PatientResponseDto read(String id) {
            Patient patient = readEntity(id);
            return mapper.toDto(patient);
        }
        @Override
        public Patient readEntity(String id) {
            return repository.findById(id)
            .orElseThrow(() -> new NotFoundException("pas-02", "Не найден Patient с id=" + id, null));
        }
    }
    \end{lstlisting}
    
    \paragraph{Mapper}\label{Реализация. Сервер. Mapper}
    
    Вспомогательный компонент для работы с ним сервисов. Нужен исключительно для преобразования объекта передачи данных запроса в сущность и сущности в объект передачи данных ответа. Полезен и метод перевода массив одного в массив другого. Пример такого класса на Листинге~\ref{mapper}. Можно использовать различные библиотеки, как Modelmapper или MapStruct, но у них есть большие проблемы -- они плохо работают с Lombok, а отказ от него значительно ухудшит код.
    
   \begin{lstlisting}[label=mapper,caption=Пример класса-маппера]
    @Component
    public class InstitutionMapper {
        public Institution toEntity(InstitutionRequestDto institutionRequestDto) {
            return Institution.builder()
            .name(institutionRequestDto.getName())
            .build();
        }
        public InstitutionResponseDto toDto(Institution institution) {
            return InstitutionResponseDto.builder()
            .id(institution.getId())
            .name(institution.getName())
            .build();
        }
    }
    \end{lstlisting}
    
    \paragraph{Repository (DAO)}\label{Реализация. Сервер. Repository}
    
    Компонент, который практически не нужно писать самостоятельно. Как сказано в пункте~\ref{Реализация. База данных}, практически всё, что касается базы данных передаётся под контроль JPA. Самостоятельно требуется сделать только несколько вещей:
    
    \begin{itemize}[nolistsep]
        \item[--] Написание интерфейса для генерируемого класса работы с базой данных
        \item[--] Свои простые запросы. По названию методов библиотека сама определит какой запрос нужен для проведения операции. Достаточно лишь передать свои параметры.
        \item[--] Свои сложные запросы. Есть возможность с помощью аннотации @Query написать любой SQL-запрос, не отходя от логики созданных сущностей. Полезно, например, для фильтрации.
    \end{itemize}
    
    Пример обычного интерфейса для Репозитория -- на Листинге~\ref{repository}. Указывается сущность, для которой нужно создать объект доступа к данным и тип его первичного ключа. После этого с помощью инъекции зависимостей можно будет использовать его в слое бизнес-логики.
    
    \begin{lstlisting}[label=repository,caption=Пример интерфейса для репозитория]
    public interface AppointmentRepository 
            extends JpaRepository<Appointment, String> {
    }
    \end{lstlisting}

    \subsubsection{Безопасность}\label{Реализация. Сервер. Безопасность}
    
    \paragraph{Хранение паролей}
    
    При добавлении пользователя логин и пароль передаются в незашифрованном виде. Хранить логин можно и без шифрования, а вот пароль -- нет. Стандартно в Spring уже есть шифровальщик паролей -- BCryptPasswordEncoder, который шифрует текст c помощью BCrypt алгоритма. Пароль хешируется и возвращается в виде строки. Эта строка будет хранить одновременно и информацию о том, что это BCrypt, и количество итераций при хешировании, и соль и, непосредственно, сам хешированный пароль.
    
    \paragraph{Ограничение доступа}
    
    С помощью Spring Security можно определять, какие url каким пользователям будут доступны.
    
    Для разрабатываемой системы хорошо подходит система ролей и доступа по ним. Роль (или другие характеристики) определяется путём нахождения пользователя в базе данных через его авторизационные данные. Если у пользователя есть необходимая роль, то доступ ему разрешается. Определяется пользователь исходя из передаваемого вместе с каждый запросом заголовка <<Authorization>>. Далее, когда пользователь уже известен, происходит предоставление доступа, либо отказ в соответствии с конфигурацией, часть которой указана на Листинге~\ref{security}.
    
    \begin{lstlisting}[label=security,caption=Пример кода для разграничения доступа]
    http.userDetailsService(userDetailsService).csrf().disable()
        .authorizeHttpRequests(auth -> auth
        .requestMatchers(HttpMethod.GET, appointmentPath + "/{appointmentId}").authenticated()
        .requestMatchers(HttpMethod.GET, appointmentPath).authenticated()
        .requestMatchers(HttpMethod.POST, appointmentPath).hasAnyAuthority(
            AccountRole.ADMIN.toString(), AccountRole.DOCTOR.toString())
        .requestMatchers(HttpMethod.PUT, appointmentPath + "/{appointmentId}").hasAnyAuthority(
            AccountRole.ADMIN.toString(), AccountRole.DOCTOR.toString())
        .requestMatchers(HttpMethod.DELETE, appointmentPath + "/{appointmentId}").hasAuthority(
            AccountRole.ADMIN.toString())
    \end{lstlisting}

    \subsubsection{Документация}\label{Реализация. Сервер. Документация}
    
    Документация, которая может пригодиться -- документация API. В случае если потребуется взаимодействовать с сервером не только написанному в рамках данного проекта, а кому-то, кому неизвестен исходный код, то она сделает разработку возможной.
    
    Для документирования есть очень удобный инструмент -- Swagger. Исходя из того, что написано в слое контроллеров и того, из чего состоят DTO он может сделать полноценную интерактивную документацию для API проекта. Выглядит это как на Рисунке~\ref{fig:Swagger}.
    
    \begin{figure}[h]
        
        \centering
        
        \includegraphics[width=0.8\linewidth]{Swagger.png}
        
        \caption{\centering Пример документации Swagger}
        
        \label{fig:Swagger}
        
    \end{figure}
    
    У него есть уже упомянутые аннотации, как @Tag, которые позволяют составлять документацию ещё и в удобном для чтения формате. Присутствует возможность отправлять запросы прямо из этой панели.
    
    Главное преимущество автодокументирования -- то, что такая документация всегда актуальна. Она подстраивается под изменения кода и не может быть такого, что она устарела.

    \subsubsection{Тестирование}\label{Реализация. Сервер. Тестирование}
    
    Основной вид тестирования, которым нужно покрывать разрабатываемую систему -- интеграционное тестирование. Это вид тестирования, который позволяет удостовериться, что на конкретный запрос при конкретном состоянии системы возвращается заранее известный ответ. Таким образом, если все интеграционные тесты выполняются и они правильно написаны, то можно быть уверенным, что сервер работает правильно.
    
    Разработка тестов -- это отдельная большая часть работы над системой. Тестировать нужно не только уже разработанную систему на наличие ошибок. Тесты нужно создавать и проводить на протяжении всей разработки, причём, что важно -- до написания кода. Этот подход называется TDD (Разработка через тестирование) и является хорошей практикой в программировании, потому что тесты пишутся "на свежую голову" по этапу проектирования, а не тогда, когда вся программа уже написана и тесты подстраиваются под неё. Эффективность тестирования при TDD выше.~\cite{cleancode}
    
    Для данной системы тесты были разработаны в соответствии с TDD в отдельном Java-проекте. Можно сказать, что каждый из методов -- это эмуляция запроса клиента. Поэтому для них требуется наличие только DTO для запроса и ответа и путей к конечным точкам приложения. Так можно будет покрыть автоматическими тестами API всё приложение.
    
    Пример автоматического теста приведён на Листинге~\ref{test}. Здесь пользователь ADMIN, который создаётся по умолчанию при запуске создаёт пользователей с разными ролями. Все они должны создаться, тест позитивный. После завершения теста созданные данные удаляются -- это важный элемент в написании автотестов, ведь это сохраняет в чистоте тестовую среду и делает тесты более предсказуемыми и отслеживаемыми.
    
    \begin{lstlisting}[label=test,caption=Пример автотеста для разработанной системы]
    @ParameterizedTest
    @Severity(SeverityLevel.CRITICAL)
    @DisplayName("Successful addition with all data from ADMIN")
    @CsvSource(value = {"ADMIN", "REGISTRAR",
    	"DOCTOR", "PATIENT"})
    void testCreatePerson_AllCorrectDataByAdmin_Created(String role) {
        PersonRequest personToCreate = PersonFactory.createPersonRequest();
        PersonResponse actual = personSteps.post(personToCreate, adminAuth, specifications.responseSpecificationV1(201), PersonResponse.class);
        assertThat(actual).isNotNull();
        assertThat(actual.getId()).isNotNull();
        PersonResponse expected = PersonFactory.createPersonResponse(actual.getId(), personToCreate);
        assertThat(actual).isEqualTo(expected);
        PersonResponse existedPerson = personSteps.get(actual.getId(), adminAuth, specifications.responseSpecificationV1(200), PersonResponse.class);
        assertThat(existedPerson).isEqualTo(expected);
        personSteps.delete(actual.getId(), adminAuth);
    }
    \end{lstlisting}
    
    Часто бывает необходимо не просто знать, что тест есть, а иметь возможность быстро понять что именно привело к непройденному тесту. В таких случаях очень помогает специально средство для визуализации тестирования. В Gradle есть такой по умолчанию, но он не наглядный. Лучшая замена ему -- Allure. Он представляет результаты тестов в виде удобного отчёта. Пример отчёта Allure для разрабатываемой системы приведён на Рисунке~\ref{fig:Allure}.
    
    \begin{figure}[h]
        
        \centering
        
        \includegraphics[width=0.8\linewidth]{Allure.png}
        
        \caption{\centering Пример визуализации результатов тестирования}
        
        \label{fig:Allure}
        
    \end{figure}
    
    Тесты бывают позитивные, которые проверяют нормальный ход работы системы, и негативные, которые проверяют правильность ошибки, появляющийся при том или ином действии. Большую часть всегда занимают негативные, потому что возможных сценариев ошибки значительно больше, чем сценариев нормальной работы. Это тоже можно увидеть на Рисунке~\ref{fig:Allure}.
    
    \newpage

    \subsection{Клиентская часть}\label{Реализация. Клиентская часть}

    \subsubsection{Структура проекта}\label{Реализация. Клиентская часть. Структура проекта}

    \subsubsection{Архитектура слоёв}\label{Реализация. Клиентская часть. Архитектура слоёв}

    \subsubsection{Пользовательский интерфейс}\label{Реализация. Клиентская часть. Пользовательский интерфейс}

    \subsubsection{Тестирование}\label{Реализация. Клиентская часть. Тестирование}

    \begin{lstlisting}[label=frontendprojectstructure,caption=Структура клиентского приложения]
    views/
        admin/
        doctor/
        registrar/
    components/
        alert/
        button/
        dialog/
        select/
        table/
        textfield/
    plugins/
    router/
    types/
    backspaceHandlers.ts
    main.ts
    masks.ts
    rules.ts
    utils.ts
    \end{lstlisting}

    \begin{figure}[h]

        \centering

        \includegraphics[width=0.9\linewidth]{Схема работы клиента.png}

        \caption{\centering Схема работы клиента}

        \label{fig:Схема работы клиента}

    \end{figure}

    \subsection{Сборка и развертывание}\label{Реализация. Сборка и развертывание}

    \newpage

    \section*{Заключение}
    \addcontentsline{toc}{section}{Заключение}

    \newpage

    \addcontentsline{toc}{section}{Список использованных источников}

    \begin{thebibliography}{}
        \bibitem{natsproektzdravoohranenie} Федеральный проект <<Создание единого цифрового контура в здравоохранении на основе единой государственной информационной системы в сфере здравоохранения (ЕГИСЗ)>> -- 2019 -- 9 августа [Электронный ресурс] -- URL: \url{https://minzdrav.gov.ru/poleznye-resursy/natsproektzdravoohranenie/tsifra/} (Дата обращения: 13.12.2022)
        \bibitem{cleancode} Мартин Р. Чистый код: создание, анализ и рефакторинг / Р. Мартин; пер. с англ. -- СПб.: Питер, 2022. -- 464 с.
        \bibitem{apiwikipedia} Википедия. API [Электронный ресурс] -- URL: \url{https://ru.wikipedia.org/wiki/API} (Дата обращения: 20.01.2023)
        \bibitem{baeldungbook} Eugen. <<Build your API with Spring>> [Электронный ресурс] -- URL: \url{https://www.baeldung.com/rest-api-spring-guide} (Дата обращения: 01.12.2022)
    \end{thebibliography}

\end{document}
